set OriginBlock null #bug: if not binded beforehand/set to null, Core is used
print "The StorageBlock where the items come from. If set to null, automatically finds Core"
jump configIgnore equal skipVars 1
set MaxPercent 0.2  #object variables
print "determines the maxinum percentage of an item in a storage block"
set IsCluster 0
print "If the anticlog will want to have a baseline of items in all storages, or a total amount of items in all storages"
set MinOriginAmount 10
print "(rss) Determines the mininum amount of an item to start working"
set MemoryWriteLocation 1
print "doesn't write at cell 1 if MemoryReadLocation >= 0"
set MemoryReadLocation -1
print "reads at cell1 only, doesnt read if MemoryReadLocation < 0"
print "for config selection, set to true(1) or false(0)" #bit selection from Username, best QOL config lel
op shl  false 0
op shl  1 1
op shl  1 2
op shl  1 3
op shl  false 4
op shl  1 5
op shl  1 6
op shl  false 7
op shl  false 8
op shl  1 9
op shl  1 10
op shl  1 11
op shl  1 12
op shl  false 13
op shl  false 14
op shl  false 15
print "Do not modify from this point, unless you know how it works lel"
op add bitSelection   #compile config into a single number (ie 101 as an example)
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
set skipVars 1
configIgnore:
jump originIgnore equal OriginBlock null #sets the Origin
set Origin OriginBlock
originIgnore:
jump coreIgnore notEqual Origin null
jump coreIgnore lessThan MinOriginAmount 0
    ubind @gamma #multiplayer mainly
    ulocate building core false @copper ox oy fo Origin
jump coreIgnore equal fo true
    ubind @mono
    sensor controlled @unit @controlled
    jump coreSet equal controlled @ctrlProcessor #preventing monos not logiced to be affected
    jump coreIgnore notEqual controlled @ctrlFormation
coreSet:
    ulocate building core false @copper ox oy fo Origin
coreIgnore:
jump bitSkip equal cell1 null #Sets the Bitselection if memory is used
jump bitSkip lessThan MemoryReadLocation 0
    read bitSelection cell1 MemoryReadLocation
bitSkip: #Determines when to check for Storages
jump storageCheck notEqual @links prevLinks #trigger storageCheck if any link (amount) is changed
jump ItemDentify equal isA 1 #do not trigger storageCheck if it is currently working
jump storageCheck greaterThanEq sC 25 #timer lel
ItemDentify: #Part2!!!
    jump storageIsPresent notEqual v1 0 #do we even have a storage block?
        op equal blink blink 0 #then start blinking
        set isA 0 #do not enable
        wait 0.5 #no epilepsy
        op add sC sC 10 #increase checks so it can be updated asap
        set dataItem 0 #do not send anything
        set typec @blast-compound #red (error color) or...
        jump j3 equal blink 0
        set typec null #absolutely nothing
    jump j3 always #immediately skip itemLoop
    storageIsPresent:
	set prevLinks @links #reset values used or update
    set bitLocation 0
    set dataItem 0
    set mv MaxValue
    set i 0
    itemLoop: #label suggests, it loops to determine what item to use
        lookup item type i
		op shl bitLocation 1 i #is at the selcted position true?:
        op and isSelected bitLocation bitSelection
		jump skip1 equal isSelected 0 #check
        sensor c1 Origin type
        jump skip1 lessThan c1 MinOriginAmount #is there anything to unload?
        sensor r1 v1 type #how much x in v1, v2...
        sensor r2 v2 type
        sensor r3 v3 type
        sensor r4 v4 type
        jump selectedAdd equal IsCluster true #take multi input or single?
        op min am1 r1 r2 #take small
        op min am2 r3 r4
        op min amount am1 am2
        jump amountCheck always 
    selectedAdd:
        op add am1 r1 r2 #combine 
        op add am2 r3 r4
        op add amount am1 am2
    amountCheck:
        jump skip1 greaterThanEq amount mv #is it the smallest out of the items?
        set typec type #if so set the output
        op add dataItem dataItem bitLocation
        set mv amount
    skip1:
        op add i i 1
        jump itemLoop lessThan i @itemCount
    set isA 1
	jump j3 lessThan mv MaxValue #is everything full?
	set isA 0
    set typec null
    set dataItem 0
    j3:
        set a -1
    buildingConfigLoop: #this loop now sets the config of buildings with enabled and itemconfig
        op add a a 1
        getlink obj a
        sensor oType obj @type
        jump skip2 equal oType @vault #skip if storage block
        jump skip2 equal oType @container
        jump skip2 equal oType @mass-driver
        jump j4 notEqual oType @memory-cell
        jump datawrite lessThan MemoryReadLocation 0 
        jump j4 equal obj cell1
        datawrite:
        write dataItem obj MemoryWriteLocation #at MemoryWriteLocation send item data
        j4:
        control enabled obj isA #enable or disable
        control config obj typec #set output
    skip2:
        jump buildingConfigLoop lessThan a @links
	op add sC sC 1
end
print "made by: Someone's Shadow #9470"
storageCheck: #set variables
	set sC 0 #reset storageCheck counter
    set v1 0 #reset storages
	set v2 0
	set v3 0
	set v4 0
	op mul BaseLineValue 99999999 MaxPercent #this var is for setting the mininum items for each storage (IsCluster = 0)
    set TotalMaxStorage 0 #this var is for setting the maxinum sum of items of every storage (IsCluster = 1)
	set lp -1
storageDetectionLoop: #detect storages via getlink loop
    op add lp lp 1
    getlink obj lp
    jump skip0 equal obj Origin
    sensor oType obj @type
    jump select equal oType @container #which blocks are considered storages
    jump select equal oType @vault
    jump select equal oType @mass-driver
    jump select equal oType @core-shard
    jump select equal oType @core-foundation
    jump select equal oType @core-nucleus
    skip0:
    		jump storageDetectionLoop lessThan lp @links
    set MaxValue BaseLineValue
    jump clusterIgnore equal IsCluster 0 #is this cluter mode?
    op mul TotalMaxStorage TotalMaxStorage MaxPercent
    set MaxValue TotalMaxStorage
    jump ItemDentify always
end
clusterIgnore:
	jump jb1 notEqual v2 0 #is v2 filled?
    set v2 v1
jb1:
    jump jb2 notEqual v3 0 #is v3 filled?
    set v3 v1
jb2:
    jump jb3 notEqual v4 0 #is v4 filled?
    set v4 v1
jb3:	
    jump ItemDentify always
end
select: #if we have found a storageblock, enter into memory
    sensor ic obj @itemCapacity
    jump ja1 notEqual v1 0 #is v1 filled?
    set v1 obj #if not set it into memory
    op add TotalMaxStorage TotalMaxStorage ic #and update TotalMaxStorage
    jump j1 always
ja1: 
    jump ja2 notEqual v2 0 #is v2 filled?
    set v2 obj
    op add TotalMaxStorage TotalMaxStorage ic
    jump j1 always
ja2:
    jump ja3 notEqual v3 0 #is v3 filled?
    set v3 obj
    op add TotalMaxStorage TotalMaxStorage ic
    jump j1 always
ja3:
    jump j1 notEqual v4 0 #is v4 filled?
    set v4 obj
    op add TotalMaxStorage TotalMaxStorage ic
j1:
    op mul ic ic MaxPercent #1000(V) or 300(C) * MaxPercent
    op min ic BaseLineValue ic #take smallest
    set BaseLineValue ic #set as new BaseLineValue
    jump skip0 always
end
#principles:
#you will only one schem, which only has one proc
#performance must be fast enough

#log: version 2.0 removed display logic, reduced calling the storage check, and mini optimizations
#log: version 2.1 added massdriver as storage option (-this cant disable massdrivers on low item)
#also rss/coreitemsaver (-maybreak monos on placement)
#log: version 2.2 improved memory interactions with new potential avenues, optimized storagecheck slightly
#log: version 2.3 renamed Core into Origin, and more Vars optimization
#also Renamed into General-AntiClog soonTM if recon logic can work, Needs! optimizations,more than the 1 sec rule
#log: version 2.4 Cluster/Baseline Mode, If connnecting other anticlog procs with memcells, infinite distance!
#also some general bugfixes and blinking is optimized, need to work on QOL on the longdistance, and too many vars :/
#log: version 2.4.1 fixed invalid at 162
#log: version 2.4.2 logiced monos are used to prevent monos from randomly being deactivated
#also: ton of comments

#Plans:
#ver 3.0 and above:
#solution to storage needing to be hardcoded + not being extremely performant heavy
    #(check failBackup1)
#QOL changes
    #(variable decl, and making it even easier to use... somehow)
#Reverse Mode 
    #(using negativeNumbers in MaxPercent? to switch into mv > MaxValue? dunno hmm)
#Recon/Factory Intergration 
    #(issue: recons/factories cant hold every item, which means dynamic config and...
    #recons have diffrent @itemCapacity for each item, which is a pain...
    #if the issue can't be resolved, this cant be General and can only be Semi)
#Automatic Config + Overrides
    #(this may be a reconstructor version feature, although might be ok?...
    #automatically setting the config based on binds, and adding in items like (silicon)...
    #if intergration is impossible, this is still applicable as QOL)
#Performance Lockdown, to insure <2 sec or at best <1sec performance
    #(this might be hard to pull off, but its a goal so its much much more easier to set MaxPercent...
    #storageCapacity - how much input being received = MaxPercent, is QOL) 
#External Schem for config via mem block display
    #(more QOL, and easier time for people who dont know to set the config of the proc)