ItemDentify: #Part2!!!
    jump storageIsPresent notEqual v1 0 #do we even have a storage block?
        jump storageIsPresent equal IgnoreBlink true #Do not blink is IgnoreBlink is set to true
        op equal blink blink 0      #then start blinking
        set isA 0                   #do not enable
        wait 0.5                    #no epilepsy
        op add sC sC 10             #increase checks so it can be updated asap
        set dataItem 0              #do not send anything
        set typec @blast-compound   #red (error color) or...
        jump j3 equal blink 0
        set typec null              #absolutely nothing
    jump j3 always              #immediately skip itemLoop
    storageIsPresent:
	set prevLinks @links #reset values used or update
    set bitLocation 0
    set dataItem 0
    set mv MaxValue
    set i 0
    itemLoop: #label suggests, it loops to determine what item to use
        lookup item type i
		op shl bitLocation 1 i #is at the selcted position true?:
        op and isSelected bitLocation bitSelection
		jump skip1 equal isSelected 0 #check
        sensor c1 Origin type
        jump skip1 lessThan c1 MinOriginAmount #is there anything to unload?
        sensor r1 v1 type #how much x in v1, v2...
        sensor r2 v2 type
        sensor r3 v3 type
        sensor r4 v4 type
    jump selectedAdd equal IsCluster true #take multi input or single?
        op min am1 r1 r2 #take small
        op min am2 r3 r4
        op min amount am1 am2
        jump amountCheck strictEqual v5 null #do we pass the vault test?
        sensor r5 v5 type #how much x in v5, v6...
        sensor r6 v6 type
        sensor r7 v7 type
        sensor r8 v8 type
        op min am1 r5 r6 #take small again 
        op min am2 r7 r8
        op min amount2 am1 am2
        op min amount amount amount2
        jump amountCheck strictEqual v9 null #do we pass the vault test again?
        set select_index -1
        storageMinRead: #what is contained in the storages?
            op add select_index select_index 1                      #loop start
            op add goBack @counter 1
            jump storageSelect always     #function call...
            jump amountCheck strictEqual select_output null         #does mentioned vault exist?
            sensor rV select_output type                            #then: do operation:
            op min amount amount rV
            jump storageMinRead always
    selectedAdd:
        op add am1 r1 r2 #combine 
        op add am2 r3 r4
        op add amount am1 am2
        jump amountCheck strictEqual v5 null #do we pass the vault test?
        sensor r5 v5 type #how much x in v5, v6...
        sensor r6 v6 type
        sensor r7 v7 type
        sensor r8 v8 type
        op add am1 r5 r6 #combine again 
        op add am2 r7 r8
        op add amount2 am1 am2
        op add amount amount amount2
        jump amountCheck strictEqual v9 null #do we pass the vault test again?
        set select_index -1
        storageAddRead: #what is contained in the storages?
            op add select_index select_index 1                      #loop start
            op add goBack @counter 1
            jump storageSelect always     #function call...
            jump amountCheck strictEqual select_output null         #does mentioned vault exist?
            sensor rV select_output type                            #then: do operation:
            op add amount amount rV
            jump storageAddRead always 
    amountCheck:
        jump skip1 greaterThanEq amount mv #is it the smallest out of the items?
        set typec type #if so set the output
        op add dataItem dataItem bitLocation
        set mv amount
    skip1:
        op add i i 1
        jump itemLoop lessThan i @itemCount
    set isA 1
	jump j3 lessThan mv MaxValue #is everything full?
	set isA 0
    set typec null
set dataItem 0 