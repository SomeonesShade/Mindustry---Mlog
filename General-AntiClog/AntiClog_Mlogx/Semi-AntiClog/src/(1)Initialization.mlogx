set OriginBlock null #the block used in reversemode, or rss
print "(Block/Bool) The StorageBlock where the items come from. If set to false, disables origin functionality"
jump configIgnore equal skipVars 1
set MaxPercent 0.2  #this functions as a buffer (filling it to full will practically clog)
print "(decimal) determines the maxinum percentage of an item in a storage block"
set FindCore true
print "(bool) If to set the Origin as the Core (via a mono), only works if OriginBlock is null"
set IsCluster false #if dealing. chained or seperated storages, no diffrence if single
print "(bool) If the anticlog will want to have a baseline of items in all storages, or a total amount of items in all storages"
set MinOriginAmount 10 #acts as a threshold for reverse mode and dont kill core lel
print "(integer) /rss/ Determines the mininum amount of an item to start working"
set MemoryWriteLocation 1 #write and read allows multiproc behavior for mainly long distance, or multiple origins
print "(whole number) doesn't write at cell 1 if MemoryReadLocation >= 0, sends out item bit config"
set MemoryReadLocation -1
print "(integer) reads at cell1 only, doesnt read if MemoryReadLocation < 0"
set IgnoreBlink false
print "disables 'blinking' (it happens when there are no vaults detected)"
print "for config selection, set to true(1) or false(0)" #bit selection from Username, best QOL config lel
op shl  false 0
op shl  1 1
op shl  1 2
op shl  1 3
op shl  false 4
op shl  1 5
op shl  1 6
op shl  false 7
op shl  false 8
op shl  1 9
op shl  1 10
op shl  1 11
op shl  1 12
op shl  false 13
op shl  false 14
op shl  false 15
print "Do not modify from this point, unless you know how it works lel"
op add bitSelection   #compile config into a single number (ex: 101 as an example)
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
jump originDisable strictEqual OriginBlock false
jump endOfSettings always 
originDisable:
set MinOriginAmount -1
endOfSettings:
set skipVars 1
configIgnore:
jump coreIgnore lessThan MinOriginAmount 0
jump originIgnore equal OriginBlock null #sets the Origin
set Origin OriginBlock
originIgnore:
jump coreIgnore notEqual Origin null
jump coreIgnore equal FindCore false
    ubind @mono
    sensor controlled @unit @controlled
jump originIgnore greaterThanEq controlled 2 #UHHHHHHHHHH
    ulocate building core false @copper ox oy fo Origin
coreIgnore:
jump bitSkip equal cell1 null #Sets the Bitselection if memory is used
jump bitSkip lessThan MemoryReadLocation 0
    read bitSelection cell1 MemoryReadLocation
bitSkip: #Determines when to check for Storages
jump storageCheck notEqual @links prevLinks     #trigger storageCheck if any link (amount) is changed
jump ItemDentify equal isA 1                    #do not trigger storageCheck if it is currently working
jump storageCheck greaterThanEq sC 25           #timer lel