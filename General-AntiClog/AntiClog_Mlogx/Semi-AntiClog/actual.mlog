set OriginBlock null
print "(Block/Bool) The StorageBlock where the items come from. If set to false, disables origin functionality"
jump configIgnore equal skipVars 1
set MaxPercent 0.2
print "(decimal) determines the maxinum percentage of an item in a storage block"
set FindCore true
print "(bool) If to set the Origin as the Core (via a mono), only works if OriginBlock is null"
set MinOriginAmount 10
print "(integer) /rss/ Determines the mininum amount of an item to start working"
p5: 
jump p5 notEqual 0 0
print "Item Configuration"
p6: 
jump p6 notEqual 0 0
print "for config selection, set to true(1) or false(0)"
op shl  false 0
op shl  1 1
op shl  1 2
op shl  1 3
op shl  false 4
op shl  1 5
op shl  1 6
op shl  false 7
op shl  false 8
op shl  1 9
op shl  1 10
op shl  1 11
op shl  1 12
op shl  false 13
op shl  false 14
op shl  false 15
p1: 
jump p1 notEqual 0 0
print "MultiStorage/Processor Settings, you will almost never use these"
p2: 
jump p2 notEqual 0 0
set IsCluster false
print "(bool) If the anticlog will want to have a baseline of items in all storages, or a total amount of items in all storages"
set MemoryWriteLocation 1
print "(whole number) doesn't write at cell 1 if MemoryReadLocation >= 0, sends out item bit config"
set MemoryReadLocation -1
print "(integer) reads at cell1 only, doesnt read if MemoryReadLocation < 0"
p3: 
jump p3 notEqual 0 0
print "Random Settings"
p4: 
jump p4 notEqual 0 0
set IgnoreBlink false
print "disables 'blinking' (it happens when there are no vaults detected)"
print "Do not modify from this point, unless you know how it works lel"
op add bitSelection  
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
jump originDisable strictEqual OriginBlock false
jump endOfSettings always
originDisable:
set MinOriginAmount -1
endOfSettings:
set skipVars 1
configIgnore:
jump coreIgnore lessThan MinOriginAmount 0
jump originIgnore equal OriginBlock null
set Origin OriginBlock
originIgnore:
jump coreIgnore notEqual Origin null
jump coreIgnore equal FindCore false
ubind @mono
sensor controlled @unit @controlled
jump originIgnore greaterThanEq controlled 2
ulocate building core false @copper ox oy fo Origin
coreIgnore:
jump bitSkip equal cell1 null
jump bitSkip lessThan MemoryReadLocation 0
read bitSelection cell1 MemoryReadLocation
bitSkip: #Determines when to check for Storages
jump storageCheck notEqual @links prevLinks
jump ItemDentify equal isA 1
jump storageCheck greaterThanEq sC 25
ItemDentify: #Part2!!!
jump storageIsPresent notEqual v1 0
jump storageIsPresent equal IgnoreBlink true
op equal blink blink 0
set isA 0
wait 0.5
op add sC sC 10
set dataItem 0
set typec @blast-compound
jump j3 equal blink 0
set typec null
jump j3 always
    storageIsPresent:
set prevLinks @links
set bitLocation 0
set dataItem 0
set mv MaxValue
set i 0
    itemLoop: #label suggests, it loops to determine what item to use
lookup item type i
op shl bitLocation 1 i
op and isSelected bitLocation bitSelection
jump skip1 equal isSelected 0
sensor c1 Origin type
jump skip1 lessThan c1 MinOriginAmount
sensor r1 v1 type
sensor r2 v2 type
sensor r3 v3 type
sensor r4 v4 type
jump selectedAdd equal IsCluster true
op min am1 r1 r2
op min am2 r3 r4
op min amount am1 am2
jump amountCheck strictEqual v5 null
sensor r5 v5 type
sensor r6 v6 type
sensor r7 v7 type
sensor r8 v8 type
op min am1 r5 r6
op min am2 r7 r8
op min amount2 am1 am2
op min amount amount amount2
jump amountCheck strictEqual v9 null
set select_index -1
        storageMinRead: #what is contained in the storages?
op add select_index select_index 1
op add goBack @counter 1
jump storageSelect always
jump amountCheck strictEqual select_output null
sensor rV select_output type
op min amount amount rV
jump storageMinRead always
    selectedAdd:
op add am1 r1 r2
op add am2 r3 r4
op add amount am1 am2
jump amountCheck strictEqual v5 null
sensor r5 v5 type
sensor r6 v6 type
sensor r7 v7 type
sensor r8 v8 type
op add am1 r5 r6
op add am2 r7 r8
op add amount2 am1 am2
op add amount amount amount2
jump amountCheck strictEqual v9 null
set select_index -1
        storageAddRead: #what is contained in the storages?
op add select_index select_index 1
op add goBack @counter 1
jump storageSelect always
jump amountCheck strictEqual select_output null
sensor rV select_output type
op add amount amount rV
jump storageAddRead always
    amountCheck:
jump skip1 greaterThanEq amount mv
set typec type
op add dataItem dataItem bitLocation
set mv amount
    skip1:
op add i i 1
jump itemLoop lessThan i @itemCount
set isA 1
jump j3 lessThan mv MaxValue
set isA 0
set typec null
set dataItem 0
j3:
set a -1
    buildingConfigLoop: #this loop now sets the config of buildings with enabled and itemconfig
op add a a 1
getlink obj a
sensor oType obj @type
jump jItemConfig equal oType @inverted-sorter
jump jItemConfig equal oType @sorter
jump skip2 equal oType @mass-driver
jump jEnable notEqual oType @memory-cell
jump datawrite lessThan MemoryReadLocation 0
jump jEnable equal obj cell1
        datawrite:
write dataItem obj MemoryWriteLocation
        jEnable:
control enabled obj isA
        jItemConfig:
control config obj typec
    skip2:
jump buildingConfigLoop lessThan a @links
op add sC sC 1
end
print "Semi-AntiClog 3.1"
print "made by: Someone's Shadow #9470"
end
storageCheck: #set variables
set sC 0
set v1 0
set v2 0
set v3 0
set v4 0
set select_readMode 0
jump storageArrayIgnore strictEqual v5 null
set select_index -1
set select_input null
storageReset: #clear all storage
op add select_index select_index 1
op add goBack @counter 1
jump storageSelect always
jump storageReset notEqual select_index null
storageArrayIgnore:
set select_index 0
op mul BaseLineValue 99999999 MaxPercent
set TotalMaxStorage 0
set lp -1
storageDetectionLoop: #detect storages via getlink loop
op add lp lp 1
getlink obj lp
jump skip0 equal obj Origin
sensor oType obj @type
jump select equal oType @container
jump select equal oType @vault
jump select equal oType @mass-driver
jump select equal oType @core-shard
jump select equal oType @core-foundation
jump select equal oType @core-nucleus
    skip0:
jump storageDetectionLoop lessThan lp @links
set select_readMode 2
set MaxValue BaseLineValue
jump clusterIgnore equal IsCluster false
op mul TotalMaxStorage TotalMaxStorage MaxPercent
set MaxValue TotalMaxStorage
jump ItemDentify always
end
clusterIgnore:
jump jb1 notEqual v2 0
set v2 v1
    jb1:
jump jb2 notEqual v3 0
set v3 v1
    jb2:
jump jb3 notEqual v4 0
set v4 v1
    jb3:
jump jb7 strictEqual v5 null
set v5 v1
    jb4:
jump jb5 notEqual v6 0
set v6 v1
    jb5:
jump jb6 notEqual v7 0
set v7 v1
    jb6:
jump jb7 notEqual v8 0
set v8 v1
    jb7:
jump ItemDentify always
end
select: #if we have found a storageblock, enter into memory
sensor ic obj @itemCapacity
jump ja1 notEqual v1 0
set v1 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja1:
jump ja2 notEqual v2 0
set v2 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja2:
jump ja3 notEqual v3 0
set v3 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja3:
jump ja4 notEqual v4 0
set v4 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja4:
jump ja5 notEqual v5 0
set v5 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja5:
jump ja6 notEqual v6 0
set v6 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja6:
jump ja7 notEqual v7 0
set v7 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja7:
jump ja8 notEqual v8 0
set v8 obj
op add TotalMaxStorage TotalMaxStorage ic
jump j1 always
    ja8:
jump skip0 strictEqual select_index null
set select_input obj
op add goBack @counter 1
jump storageSelect always
op add select_index select_index 1
op add TotalMaxStorage TotalMaxStorage ic
j1:
op mul ic ic MaxPercent
op min ic BaseLineValue ic
set BaseLineValue ic
jump skip0 always
end
storageSelect: #select_input, select_output, select_readMode, goBack, select_index
op mul selectStorage select_index 4
op add selectStorage selectStorage select_readMode
op add @counter selectStorage @counter
set v9 select_input
set @counter goBack
set select_output v9
set @counter goBack
set v10 select_input
set @counter goBack
set select_output v10
set @counter goBack
set v11 select_input
set @counter goBack
set select_output v11
set @counter goBack
set v12 select_input
set @counter goBack
set select_output v12
set @counter goBack
set v13 select_input
set @counter goBack
set select_output v13
set @counter goBack
set v14 select_input
set @counter goBack
set select_output v14
set @counter goBack
set v15 select_input
set @counter goBack
set select_output v15
set @counter goBack
set v16 select_input
set @counter goBack
set select_output v16
set @counter goBack
set v17 select_input
set @counter goBack
set select_output v17
set @counter goBack
set v18 select_input
set @counter goBack
set select_output v18
set @counter goBack
set v19 select_input
set @counter goBack
set select_output v19
set @counter goBack
set v20 select_input
set @counter goBack
set select_output v20
set @counter goBack
set select_index null
set @counter goBack
set select_output null
set @counter goBack
end
print "Semi-AntiClog 3.1"
print "made by: Someone's Shadow #9470"
end

#stdlib functions

print "Made with mlogx"
print "github.com/BalaM314/mlogx/"