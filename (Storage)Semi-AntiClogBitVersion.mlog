set OriginBlock null #bug: if not binded beforehand/set to null, Core is used
print "The StorageBlock where the items come from. If set to null, automatically finds Core"
jump configIgnore equal skipVars 1
set MaxPercent 0.2  #object variables
print "determines the maxinum percentage of an item in a storage block"
set IsCluster 0
print "If the anticlog will want to have a baseline of items in all storages, or a total amount of items in all storages"
set MinOriginAmount 10
print "(rss) Determines the mininum amount of an item to start working"
set MemoryWriteLocation 1
print "doesn't write at cell 1 if MemoryReadLocation >= 0"
set MemoryReadLocation -1
print "reads at cell1 only, doesnt read if MemoryReadLocation < 0"
print "for config selection, set to true(1) or false(0)"
op shl  false 0
op shl  1 1
op shl  1 2
op shl  1 3
op shl  false 4
op shl  1 5
op shl  1 6
op shl  false 7
op shl  false 8
op shl  1 9
op shl  1 10
op shl  1 11
op shl  1 12
op shl  false 13
op shl  false 14
op shl  false 15
print "Do not modify from this point, unless you know how it works lel"
op add bitSelection  
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
op add bitSelection bitSelection 
set skipVars 1
configIgnore:
jump originIgnore equal OriginBlock null #sets the Origin
set Origin OriginBlock
originIgnore:
jump coreIgnore notEqual Origin null
jump coreIgnore lessThan MinOriginAmount 0
    ubind @gamma
    ulocate building core false @copper ox oy fo Origin
jump coreIgnore equal fo true
    ubind @mono
    ulocate building core false @copper ox oy fo Origin
coreIgnore:
jump bitSkip equal cell1 null #Sets the Bitselection if memory is used
jump bitSkip lessThan MemoryReadLocation 0
    read bitSelection cell1 MemoryReadLocation
bitSkip:
jump storageCheck notEqual @links prevLinks #Determines when to check for Storages
jump ItemDentify equal isA 1
jump storageCheck greaterThanEq sC 25
ItemDentify: #Part2!!!
    jump storageIsPresent notEqual v1 0 #do we even have a storage block?
        op equal blink blink 0
        set isA 0
        wait 0.5
        op add sC sC 10
        set dataItem 0
        set typec @blast-compound
        jump j3 equal blink 0
        set typec null #then blink
    jump j3 always
    storageIsPresent:
	set prevLinks @links #reset values used or update
    set bitLocation 0
    set dataItem 0
    set mv MaxValue
    set i 0
    itemLoop: #label suggests, it loops to determine what item to use
        lookup item type i
		op shl bitLocation 1 i #is at the selcted position true?:
        op and isSelected bitLocation bitSelection
		jump skip1 equal isSelected 0 #check
        sensor c1 Origin type
        jump skip1 lessThan c1 MinOriginAmount #is there anything to unload?
        sensor r1 v1 type #how much x in v1, v2...
        sensor r2 v2 type
        sensor r3 v3 type
        sensor r4 v4 type
        jump selectedAdd equal IsCluster true #take multi input or single?
        op min am1 r1 r2 #take small
        op min am2 r3 r4
        op min amount am1 am2
        jump amountCheck always 
    selectedAdd:
        op add am1 r1 r2 #combine 
        op add am2 r3 r4
        op add amount am1 am2
    amountCheck:
        jump skip1 greaterThanEq amount mv #is it the smallest out of the items?
        set typec type #if so set the output
        op add dataItem dataItem bitLocation
        set mv amount
    skip1:
        op add i i 1
        jump itemLoop lessThan i @itemCount
    set isA 1
	jump j3 lessThan mv MaxValue #is everything full?
	set isA 0
    set typec null
    set dataItem 0
    j3:
        set a -1
    buildingConfigLoop: #this loop now sets the config of buildings with enabled and itemconfig
        op add a a 1
        getlink obj a
        sensor oType obj @type
        jump skip2 equal oType @vault #skip if storage block
        jump skip2 equal oType @container
        jump skip2 equal oType @mass-driver
        jump j4 notEqual oType @memory-cell
        jump datawrite lessThan MemoryReadLocation 0 
        jump j4 equal obj cell1
        datawrite:
        write dataItem obj MemoryWriteLocation #at MemoryWriteLocation send item data
        j4:
        control enabled obj isA #enable or disable
        control config obj typec #set output
    skip2:
        jump buildingConfigLoop lessThan a @links
	op add sC sC 1
end
print "made by: Someone's Shadow #9470"
storageCheck: #set variables
	set sC 0
    set v1 0
	set v2 0
	set v3 0
	set v4 0
	op mul BaseLineValue 99999999 MaxPercent
    set TotalMaxStorage 0
	set lp -1
storageDetectionLoop: #detect storages
    op add lp lp 1
    getlink obj lp
    jump skip0 equal obj Origin
    sensor oType obj @type
    jump select equal oType @container
    jump select equal oType @vault
    jump select equal oType @mass-driver
    jump select equal oType @core-shard
    jump select equal oType @core-foundation
    jump select equal oType @core-nucleus
    skip0:
    		jump storageDetectionLoop lessThan lp @links
    set MaxValue BaseLineValue
    jump clusterIgnore IsCluster 0 #is this cluter mode?
    op mul TotalMaxStorage TotalMaxStorage MaxPercent
    set MaxValue TotalMaxStorage
    jump ItemDentify always
end
clusterIgnore:
	jump jb1 notEqual v2 0 #is v2 filled?
    set v2 v1
jb1:
    jump jb2 notEqual v3 0 #is v3 filled?
    set v3 v1
jb2:
    jump jb3 notEqual v4 0 #is v4 filled?
    set v4 v1
jb3:	
    jump ItemDentify always
end
select: #if we have found a storageblock, enter into memory
    sensor ic obj @itemCapacity
    jump ja1 notEqual v1 0 #is v1 filled?
    set v1 obj
    op add TotalMaxStorage TotalMaxStorage ic
    jump j1 always
ja1: 
    jump ja2 notEqual v2 0 #is v2 filled?
    set v2 obj
    op add TotalMaxStorage TotalMaxStorage ic
    jump j1 always
ja2:
    jump ja3 notEqual v3 0 #is v3 filled?
    set v3 obj
    op add TotalMaxStorage TotalMaxStorage ic
    jump j1 always
ja3:
    jump j1 notEqual v4 0 #is v4 filled?
    set v4 obj
    op add TotalMaxStorage TotalMaxStorage ic
j1:
    op mul ic ic MaxPercent #1000(V) or 300(C) * MaxPercent
    op min ic BaseLineValue ic #take smallest
    set BaseLineValue ic #set as new BaseLineValue
    jump skip0 always
end
#principles:
#you will only one schem, which only has one proc
#performance must be fast enough

#log: version 2.0 removed display logic, reduced calling the storage check, and mini optimizations
#log: version 2.1 added massdriver as storage option (-this cant disable massdrivers on low item)
#also rss/coreitemsaver (-maybreak monos on placement)
#log: version 2.2 improved memory interactions with new potential avenues, optimized storagecheck slightly
#log: version 2.3 renamed Core into Origin, and more Vars optimization
#also Renamed into General-AntiClog soonTM if recon logic can work, Needs! optimizations,more than the 1 sec rule

#log: version 2.4 Cluster/Baseline Mode, If connnecting other anticlog procs with memcells, infinite distance!
#also some general bugfixes and blinking is optimized, need to work on QOL on the longdistance, and too many vars :/

#Plans:
#ver 3.0+
#QOL changes
#Reverse Mode
#Recon/Factory Intergration
#Automatic Config + Overrides
#Performance Lockdown, to insure <2 sec or at best <1sec performance
#External Schem for config via mem block display